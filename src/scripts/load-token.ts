import { Network, TransferEvent, ZeroAddress, prototype, totalSupply } from '../const'
import { Net } from '../net'
import { Thor } from '../thor-rest'
import { Token, AssetConfig } from '../tokens'
import { promises as fs } from 'fs'
import * as path from 'path'

const ghIO = new Net("https://vechain.github.io")

const list: { [index: string]: { [index: string]: Token } } = {
    [Network.MainNet]: {},
    [Network.TestNet]: {},
}

const networks = {
    main: new Net('https://sync-mainnet.vechain.org'),
    test: new Net('https://sync-testnet.vechain.org')
}

const red = (input: string) => {
    return `\x1b[31m${input}\x1b[0m`
}

const tokenGenesis = async (token: Token, net: Network): Promise<Required<Token>['genesis'] | null> => {
    // wrapped token has different schema, no genesis, skip here
    if (token.symbol === 'VVET') {
        return null
    }
    const thor = new Thor(net === Network.MainNet ? networks.main : networks.test, net)

    let events = await thor.filterEventLogs({
        range: { unit: 'block', from: 0, to: Number.MAX_SAFE_INTEGER },
        options: { offset: 0, limit: 1 },
        criteriaSet: [{ address: token.address, topic0: prototype.$Master.signature }],
        order: 'asc'
    })
    const birthNumber = events[0].meta!.blockNumber

    const ret = await thor.explain({
        clauses: [{
            to: token.address,
            value: '0x0',
            data: totalSupply.encode()
        }]
    }, birthNumber.toString())

    const supply = totalSupply.decode(ret[0].data).supply

    const evCnt = 50
    events = await thor.filterEventLogs({
        range: { unit: 'block', from: birthNumber, to: Number.MAX_SAFE_INTEGER },
        options: { offset: 0, limit: evCnt },
        criteriaSet: [{ address: token.address, topic0: TransferEvent.signature }],
        order: 'asc'
    })
    const decodedEv = events.map(x => {
        return { decoded: TransferEvent.decode(x.data, x.topics), meta: x.meta }
    })
    const genesis: Required<Token>['genesis'] = {}

    // account -> balance
    const accounts = new Map<string, bigint>()
    if (BigInt(supply) !== BigInt(0)) {
        const { _from, _to, _value } = decodedEv[0].decoded
        // if sent from zero address, it will be recognized as 
        if (_from !== ZeroAddress) {
            genesis[_from] = supply
            accounts.set(_from, BigInt(supply))
        }
    }
    // otherwise it's on-demand mint, no genesis

    // run initial transfer check
    for (const ev of decodedEv) {
        const { _from, _to, _value } = ev.decoded

        const from = accounts.get(_from) || BigInt(0)
        const to = accounts.get(_to) || BigInt(0)
        const value = BigInt(_value)

        if (_from !== ZeroAddress) {
            if (from < value) {
                throw new Error('initial transfer check failed')
            }
            accounts.set(_from, from - value)
        }
        accounts.set(_to, to + value)
    }

    return Object.keys(genesis).length ? genesis : null
}

const makeFileContent = (list: { [index: string]: { [index: string]: Token } }) => {
    const assets = Object.keys(AssetConfig).filter(x => x !== 'VET' && x !== 'VTHO')
    let index = assets.length

    for (const [_,v] of Object.entries(list[Network.MainNet])) { 
        if(assets.includes(v.symbol)) {
            continue
        }
        assets.push(v.symbol)
        AssetConfig[v.symbol] = {
            type: index++,
            decimals: v.decimals
        }
    }

    for (const [_,v] of Object.entries(list[Network.TestNet])) { 
        if(assets.includes(v.symbol)) {
            continue
        }
        assets.push(v.symbol)
        AssetConfig[v.symbol] = {
            type: index++,
            decimals: v.decimals
        }
    }

    let asset = `export enum AssetType { VET = 0, VTHO, '${assets.join("', '")}'}`

    return `/* this file is generated by scripts/load-token */
import { Network } from './const'
${asset}
export interface Token {
    name: string
    address: string
    symbol: string
    decimals: number,
    genesis?: {
        [address: string]: string
    }
}
export const list:{ [index: string]: { [index: string]: Token } } = ${JSON.stringify(list, null, 4)}
export const getToken = (net: Network, symbol: string) => {
    if (!list[net]) {
        throw new Error('unknown network: ' + net)
    }

    if (!list[net][symbol]) {
        throw new Error('unknown token: ' + symbol+ ' @'+ (net === Network.MainNet ? 'MainNet': 'TestNet'))
    }

    return list[net][symbol]
}
export const AssetConfig: {[index:string]:{type:number, decimals: number}} = ${JSON.stringify(AssetConfig, null, 4)}
export const updateTime = ${new Date().getTime()}
`
}

const loadToken = async (net: Network) => { 
    let uri = '/token-registry/main.json'
    if (net === Network.TestNet) {
        uri = '/token-registry/test.json'
    }

    const tokens = await ghIO.http<Array<Omit<Token, 'genesis'>>>('GET', uri)
    for (const item of tokens) {
        if (item.symbol === 'VTHO' || item.symbol === 'VET') {
            continue
        }

        const token: Token = {
            name: item.name,
            symbol: item.symbol,
            address: item.address,
            decimals: item.decimals
        }
        try {
            const genesis = await tokenGenesis(token, net)
            if (genesis) {
                token.genesis = genesis
            }
        } catch (e) {
            console.log(red(`failed to get genesis for ${token.symbol} on ${net===Network.MainNet?'MainNet':'TestNet'}`))
            console.log(e)
            continue
        }
        
        list[net][token.symbol] = token
    }
}

const verifyTokenType = () => {
    const content = require('../tokens')

    for (const [k, v] of Object.entries(content.AssetConfig)) { 
        if (content.AssetType[k] !== (v as any).type) {
            throw new Error(`type for ${k} is not correct, wanted ${content.AssetType[k]}, got ${(v as any).type}`)
        }
    }
}

void (async () => {
    await loadToken(Network.MainNet)
    await loadToken(Network.TestNet)

    const file = await fs.open(path.join(__dirname, "../tokens.ts"), 'w')
    await file.write(makeFileContent(list))
    await file.close()

    verifyTokenType()
    process.exit(0)
})().catch((e) => {
    console.log(e)
    process.exit(-1)
})